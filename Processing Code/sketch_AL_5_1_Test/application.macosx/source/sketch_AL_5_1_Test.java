/* autogenerated by Processing revision 1272 on 2021-04-24 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class sketch_AL_5_1_Test extends PApplet {

/*
  This is the standard version, to be benchmarked against others
 */
World world;
PFont myFontC;
PFont myFontI;
int timer;
float totalTime = 0;
Table table;
FloatList OpusN = new FloatList();
FloatList HachiN = new FloatList();
FloatList PlantN = new FloatList();

//Variable List

//Hachi
float HachiAgeMin = 3000;
float HachiAgeMax = 6000;
float HachiHtrMin = 5;
float HachiHtrMax = 9;
float HachiHungerMin = 2;
float HachiHungerMax = 5;
float HachiVisionMin = 20;
float HachiVisionMax = 90;
float HachiSpeedMin = 1;
float HachiSpeedMax = 4;

//Opus
float OpusAgeMin = 2000;
float OpusAgeMax = 6000;
float OpusHtrMin = 2;
float OpusHtrMax = 7;
float OpusHungerMin = 2;
float OpusHungerMax = 4;
float OpusVisionMin = 30;
float OpusVisionMax = 120;
float OpusSpeedMin = 2;
float OpusSpeedMax = 5;

//Plant

float minPlantVal = 10;
float PlantRegenVal = 0.004f;
float maxPlantVal = 100;

 public void setup() {
  /* size commented out by preprocessor */;

  //All objects living within a 'World'
  world = new World(10, 40, 70); //refers to number of Hachi(3rd in food chain) Opus(2nd in food chain) Plants on start

  //load in custom fonts
  myFontC = loadFont("CircularStd-Medium-14.vlw");
  myFontI = loadFont("Inter-Regular-12.vlw");
  table = new Table();

  table.addColumn("opus-number");
  table.addColumn("opus-avg-speed");
  table.addColumn("opus-avg-vision");
  table.addColumn("opus-avg-htr");
  table.addColumn("opus-avg-age");
  table.addColumn("hachi-number");
  table.addColumn("hachi-avg-speed");
  table.addColumn("hachi-avg-vision");
  table.addColumn("hachi-avg-htr");
  table.addColumn("hachi-avg-age");
  table.addColumn("plant-number");
}

 public void draw() {
  background(359, 200);
  totalTime += millis()/1000;
  world.run();
  if (millis() - timer >= 200) {
    TableRow newRow = table.addRow();
    newRow.setInt("opus-number", world.op.size());
    newRow.setFloat("opus-avg-speed", world.OpusAvgSpeed);
    newRow.setFloat("opus-avg-vision", world.OpusAvgVision);
    newRow.setFloat("opus-avg-htr", world.OpusAvgHtr);
    newRow.setFloat("opus-avg-age", world.OpusAvgAge);
    newRow.setInt("hachi-number", world.hc.size());
    newRow.setFloat("hachi-avg-speed", world.HachiAvgSpeed);
    newRow.setFloat("hachi-avg-vision", world.HachiAvgVision);
    newRow.setFloat("hachi-avg-htr", world.HachiAvgHtr);
    newRow.setFloat("hachi-avg-age", world.HachiAvgAge);
    newRow.setInt("plant-number", world.plnt.size());
    OpusN.append(world.op.size());
    HachiN.append(world.hc.size());
    PlantN.append(world.plnt.size());
    totalTime += 1;
    timer = millis();
  }
  noFill();
  stroke(0);
  beginShape();
  for (int i = 0; i < OpusN.size(); i++) {
    float y = map(OpusN.get(i), 0, 200, height-10, height-110);
    float x = map(i, 0, OpusN.size(), 210, 340);
    vertex(x, y);
  }
  endShape();
  beginShape();
  for (int i = 0; i < HachiN.size(); i++) {
    float y = map(HachiN.get(i), 0, 100, height-10, height-110);
    float x = map(i, 0, HachiN.size(), 560, 690);
    vertex(x, y);
  }
  endShape();
  beginShape();
  for (int i = 0; i < PlantN.size(); i++) {
    float y = map(PlantN.get(i), 0, 100, height-10, height-110);
    float x = map(i, 0, PlantN.size(), 720, 850);
    vertex(x, y);
  }
  endShape();

  //println(totalTime);

  if (totalTime>5000) {
    saveTable(table, "analytics/data.csv");
    exit();
  }
}
/*
  This creates the structure for the DNA, not that important in the larger scheme of things
*/
class DNA {
  float[][] genes; 

  DNA() {
    genes = new float[5][1];
    for (int j = 0; j < genes.length; j++) {
      for (int i = 0; i < 1; i++) {
        genes[j][i] = random(0, 1);
      }
    }
  }

  DNA(float[][] newgenes) {
    genes = newgenes;
  }

   public DNA copy() {
    float[][] newgenes = new float[genes.length][1]; 
    for (int j = 0; j < genes.length; j++) {
      for (int i = 0; i < genes.length; i++) {
        newgenes[j][i] = genes[j][i];
      }
    }

    return new DNA(newgenes);
  }

   public void mutate(float m) {//edit
    for (int i = 0; i < genes.length; i++) {
      if (random(1) < m) {
        genes[i][1] = random(0, 1);
      }
    }
  }
}
/*
3rd in food chain
Eats Opus
*/
class Hachi {
  PVector loc;
  PVector vel;
  PVector acc;
  float tx, ty, tz;
  float px, py;
  float maxforce;
  float maxspeed, vision, reproduce, age, col;
  float hmaxspeed;
  float hunger;
  float nx, ny = 0.0f;
  DNA dna;
  float r;
  //DNA Metrics
  //colour


  Hachi(PVector l, DNA dna_) {
    dna = dna_;
    maxspeed = map(dna.genes[0][0], 0, 1, HachiSpeedMin, HachiSpeedMax); //maximum speed
    hmaxspeed = maxspeed+1; //sets higher version of maxspeed when really hungry
    vision = map(dna.genes[1][0], 0, 1, HachiVisionMin, HachiVisionMax); //radius of how much it can 'sense' around it
    reproduce = map(dna.genes[2][0], 0, 1, HachiHtrMin, HachiHtrMax); //amount of food needed before it can reproduce
    age = map(dna.genes[3][0], 0, 1, HachiAgeMin, HachiAgeMax); //how long does it naturally live for
    hunger = map(dna.genes[4][0], 0, 1, HachiHungerMin, HachiHungerMax); //how much food is it born with
    col = map(dna.genes[0][0], 0, 1, 0, 359); //colour mapped to maximum speed

    //each being is basically a vector
    loc = new PVector(l.x, l.y);
    acc = new PVector(0, 0);
    vel = new PVector(0, 0);

    px = loc.x;
    py = loc.y;
    
    //turning speed
    maxforce = 0.1f;
    
    //initial radius of being, but immediately resets to how much food it has
    r = 1;
    
    //noise variables for random movement
    tx = random(100);
    ty = random(10000);
    tz = random(10);
  }
   public void run(ArrayList<Opus> o, ArrayList<Hachi> h) { //takes in arrays of Opus (food) and fellow Hachi
    update(o);
    cull(h);
    
    //finds location of all Opus (food) 
    FloatList opusDistance = new FloatList();
    for (int i = 0; i<o.size(); i++) {
      Opus part = o.get(i);
      PVector opusPosition = part.loc;
      float d = PVector.dist(loc, opusPosition);
      opusDistance.append(d);
    }
    float minOpusVal = vision+10;
    PVector opusPosition = new PVector();
    float opusSize = 1000;
    if (opusDistance.size()>0) {
      minOpusVal = opusDistance.min();
      int opusTemp = opusDistance.index(minOpusVal);
      opusPosition = o.get(opusTemp).loc;
      opusSize = o.get(opusTemp).r;
    }

    //finds location of all Hachi
    FloatList hachiDistance = new FloatList();
    for (int i = 0; i<h.size(); i++) {
      Hachi part = h.get(i);
      float d = PVector.dist(loc, part.loc);
      if ((d==0.0f)) {
        hachiDistance.append(1000);
      } else {
        hachiDistance.append(d);
      }
    }
    float minHachiVal = vision+10;
    PVector hachiPosition = new PVector();
    PVector ltemp = new PVector(random(width), random(height));
    DNA dnatemp = new DNA();
    Hachi exo = new Hachi(ltemp, dnatemp);
    if (hachiDistance.size()>0) {
      minHachiVal= hachiDistance.min();
      int hachiTemp = hachiDistance.index(minHachiVal);
      exo = h.get(hachiTemp);
      hachiPosition = h.get(hachiTemp).loc;
    } 
    
    //Controllers (switches between active states based on set parameters (b/w looking for food, mates, or just randomly moving around
    //if ((minOpusVal<vision)&&(hunger<4)&&(opusSize<r*1.2)) { //hunt for food within its 'vision' and if food isn't too much bigger than it
      if ((minOpusVal<vision)&&(hunger<4)) {
      stroke(309, 100);
      line(loc.x, loc.y, opusPosition.x, opusPosition.y);
      arrive(opusPosition);
    } else if ((minHachiVal<vision)&&(hunger>reproduce)&&(exo.hunger>exo.reproduce)) { //if ready, look for eligible mates
      stroke(309, 100);
      line(loc.x, loc.y, hachiPosition.x, hachiPosition.y);
      arrive(hachiPosition);
      if ((minHachiVal<10)&&(exo.hunger>exo.reproduce)) { //if mate found, swap genes with DNA
        DNA dna_ = new DNA();
        for (int i=0; i<dna_.genes.length; i++) {
          if (random(1)<0.5f) {
            dna_.genes[i][0]=dna.genes[i][0];
          } else {
            dna_.genes[i][0]=exo.dna.genes[i][0];
          }
        }
        if (random(1)<0.2f) {
          for (int i=0; i<dna_.genes.length; i++) {
            if (random(1)<0.5f) {
              dna_.genes[i][0] += random(-0.01f, 0.01f);
            }
          }
        }

        PVector l = new PVector(loc.x, loc.y);
        h.add(new Hachi(l, dna_));
        //println("new: "+(hunger-htr)+" "+(exo.hunger-exo.htr));
        hunger = 2;
        exo.hunger = 2;
      }
    } else { //if nothing matches above states, randomly move around
      nx = map(noise(tx, tz), 0, 1, -0.1f, 0.1f);
      ny = map(noise(ty, tz), 0, 1, -0.1f, 0.1f);
      acc.y = ny;
      acc.x = nx;
    }
  }

   public void cull(ArrayList<Hachi> h) { //killing mechanism-either of old age, or of hunger
    for (int i = 0; i<h.size(); i++) {
      Hachi part = h.get(i);
      if (part.hunger<0) {
        h.remove(i);
        println("Hachi Food Death");
        //p.add(new Plant());
      }
      if (part.age<0) {
        h.remove(i);
         println("Hachi Age Death");
        //p.add(new Plant());
      }
    }
  }


   public void display() { //displays stuff
    colorMode(HSB, 360, 100, 100);
    fill(0);
    noStroke();
    r = map(hunger, 0, 10, 0, 8);
    float theta = vel.heading() + PI/2;
    pushMatrix();
    translate(loc.x, loc.y);
    //text(hunger, 0, 0);
    rotate(theta);
    beginShape();
    noStroke();
    vertex(0, -r*2);
    vertex(-r, r*2);
    vertex(r, r*2);
    endShape(CLOSE);
    popMatrix();
  }
   public void update(ArrayList<Opus> p) { //consolidates everything to keep it smooth and moving
    wall();
    vel.add(acc);
    vel.limit(maxspeed);
    loc.add(vel);
    acc.mult(0);
    if (hunger<1) {
      maxspeed=hmaxspeed;
    }
    //hunger += -0.001;
    hunger += map(vel.mag(), 0, maxspeed, -0.001f, -0.005f);

    tx += 0.1f;
    ty += 0.1f;
    tz += 0.1f;

    age--;
    if (hunger<10) {
      eat(p);
    }
    display();
  }

   public void eat(ArrayList<Opus> o) { //eating engine
    for (int i = 0; i<o.size(); i++) {
      Opus part = o.get(i);
      PVector foodposition = part.loc;
      float d = PVector.dist(loc, foodposition);

      if (d < r*3) {
        hunger++;
        o.remove(i);
      }
    }
  }

   public void applyForce(PVector force) { //ehh boring bit dont touch
    acc.add(force);
  }
  
   public void arrive(PVector target) { //provides a nice easing approach to target (food or mate)
    //fill(0);
    //text("eat", loc.x, loc.y+10);
    PVector desired = PVector.sub(target, loc);
    float d = desired.mag();
    desired.normalize();
    if (d < 20) {
      float m = map(d, 0, 20, 0, maxspeed);
      desired.mult(m);
    } else {
      desired.mult(maxspeed);
    }
    PVector steer = PVector.sub(desired, vel);
    steer.limit(maxforce);
    applyForce(steer);
  }

   public void wall() { //keeps everyone within boundaries
    PVector desired = vel.copy();
    if (loc.x > width-15) {
      desired = new PVector(maxspeed * -1, vel.y);
    } else if (loc.x < 15) {
      desired = new PVector(maxspeed, vel.y);
    }
    if (loc.y > height-15) {
      desired = new PVector(vel.x, maxspeed * -1);
    } else if (loc.y < 15) {
      desired = new PVector(vel.x, maxspeed);
    }
    PVector steer = PVector.sub(desired, vel);
    steer.limit(maxforce);
    applyForce(steer);
  }
}
/*
2nd in food chain
Eats Food
Eaten by Opus
*/
class Opus {
  PVector loc;
  PVector vel;
  PVector acc;
  float tx, ty, tz;
  float px, py;
  float maxforce;
  float maxspeed, vision, reproduce, age, col;
  float hmaxspeed;
  float hunger;
  float nx, ny = 0.0f;
  DNA dna;
  float r;
  //DNA Metrics
  //colour


  Opus(PVector l, DNA dna_) {
    dna = dna_;
    maxspeed = map(dna.genes[0][0], 0, 1, OpusSpeedMin, OpusSpeedMax); //maximum speed
    hmaxspeed = maxspeed+1; //sets higher version of maxspeed when really hungry
    vision = map(dna.genes[1][0], 0, 1, OpusVisionMax, OpusVisionMax); //radius of how much it can 'sense' around it
    reproduce = map(dna.genes[2][0], 0, 1, OpusHtrMin, OpusHtrMax); //amount of food needed before it can reproduce
    age = map(dna.genes[3][0], 0, 1, OpusAgeMin, OpusAgeMax); //how long does it naturally live for
    hunger = map(dna.genes[4][0], 0, 1, OpusHungerMin, OpusHungerMax); //how much food is it born with
    col = map(dna.genes[0][0], 0, 1, 0, 127); //colour mapped to maximum speed

    loc = new PVector(l.x, l.y);
    acc = new PVector(0, 0);
    vel = new PVector(0, 0);

    px = loc.x;
    py = loc.y;

    maxforce = 0.3f;
    r = 1;
    //timeAlive=random(4000, 5000);

    tx = random(100);
    ty = random(10000);
    tz = random(10);
  }
   public void run(ArrayList<Plant> p, ArrayList<Opus> o) {
    update(p);
    cull(o, p);

    FloatList plantDistance = new FloatList();
    for (int i = 0; i<p.size(); i++) {
      Plant part = p.get(i);
      PVector foodposition = part.loc;
      float d = PVector.dist(loc, foodposition);
      plantDistance.append(d);
    }
    float minPlantVal = plantDistance.min();
    int plantTemp = plantDistance.index(minPlantVal);
    PVector plantPosition = p.get(plantTemp).loc;
    float plantSize = p.get(plantTemp).r;

    FloatList opusDistance = new FloatList();
    for (int i = 0; i<o.size(); i++) {
      Opus part = o.get(i);
      float d = PVector.dist(loc, part.loc);
      if ((d==0.0f)) {
        opusDistance.append(1000);
      } else {
        opusDistance.append(d);
      }
    }

    float minOpusVal = vision+10;
    PVector ltemp = new PVector(random(width), random(height));
    DNA dnatemp = new DNA();
    Opus exo = new Opus(ltemp, dnatemp);
    PVector opusPosition = new PVector();
    if (opusDistance.size()>0) {
      minOpusVal = opusDistance.min();
      int opusTemp = opusDistance.index(minOpusVal);
      exo = o.get(opusTemp);
      opusPosition = o.get(opusTemp).loc;
    }


    //Controllers
    //if ((minPlantVal<vision)&&(hunger<4)&&(plantSize<r*6)) {
      if ((minPlantVal<vision)&&(hunger<4)) {
      //if ((minPlantVal<vision)&&(hunger<4)) {
      stroke(359, 100);
      line(loc.x, loc.y, plantPosition.x, plantPosition.y);
      arrive(plantPosition);
    } else if ((minOpusVal<vision)&&(hunger>reproduce)&&(exo.hunger>exo.reproduce)) {
      stroke(359, 100);
      line(loc.x, loc.y, opusPosition.x, opusPosition.y);
      arrive(opusPosition);
      if ((minOpusVal<10)&&(exo.hunger>exo.reproduce)) {
        DNA dna_ = new DNA();
        for (int i=0; i<dna_.genes.length; i++) {
          if (random(1)<0.5f) {
            dna_.genes[i][0]=dna.genes[i][0];
          } else {
            dna_.genes[i][0]=exo.dna.genes[i][0];
          }
        }
        if (random(1)<0.2f) {
          for (int i=0; i<dna_.genes.length; i++) {
            if (random(1)<0.5f) {
              dna_.genes[i][0] += random(-0.01f, 0.01f);
            }
          }
        }

        PVector l = new PVector(loc.x, loc.y);
        o.add(new Opus(l, dna_));
        //println("new: "+(hunger-htr)+" "+(exo.hunger-exo.htr));
        hunger = 2;
        exo.hunger = 2;
      }
    } else {
      nx = map(noise(tx, tz), 0, 1, -0.1f, 0.1f);
      ny = map(noise(ty, tz), 0, 1, -0.1f, 0.1f);
      acc.y = ny;
      acc.x = nx;
    }
  }

   public void cull(ArrayList<Opus> o, ArrayList<Plant> p) { //killing mechanism-either of old age, or of hunger
    for (int i = 0; i<o.size(); i++) {
      Opus part = o.get(i);
      if (part.hunger<0) {
        o.remove(i);
        println("Opus Hunger Death");
        p.add(new Plant());
      }
      if (part.age<0) {
        o.remove(i);
        println("Opus Age Death");
        p.add(new Plant());
      }
    }
  }


   public void display() { //displays stuff
    colorMode(HSB, 360, 100, 100);
    fill(col, 70, 70);
    noStroke();
    r = map(hunger, 0, 10, 0, 8);
    float theta = vel.heading() + PI/2;
    pushMatrix();
    translate(loc.x, loc.y);
    //text(vel.mag(), 0, 0);
    rotate(theta);
    beginShape();
    noStroke();
    vertex(0, -r*2);
    vertex(-r, r*2);
    vertex(r, r*2);
    endShape(CLOSE);
    popMatrix();
  }
   public void update(ArrayList<Plant> p) { //consolidates everything to keep it smooth and moving
    wall();
    vel.add(acc);
    vel.limit(maxspeed);
    loc.add(vel);
    acc.mult(0);

    if (hunger<1) {
      maxspeed=hmaxspeed;
    }
    //hunger += -0.001;
    hunger += map(vel.mag(), 0, maxspeed, -0.001f, -0.005f);

    tx += 0.1f;
    ty += 0.1f;
    tz += 0.1f;

    age--;
    if (hunger<10) {
      eat(p);
    }
    display();
  }

   public void eat(ArrayList<Plant> p) { //eating engine
    for (int i = 0; i<p.size(); i++) {
      Plant part = p.get(i);
      PVector foodposition = part.loc;
      float d = PVector.dist(loc, foodposition);
      float pSize = part.r;

      if (d < r*3) {

        hunger+=map(pSize, 1, 10, 1, 2);
        p.remove(i);
      }
    }
  }

   public void applyForce(PVector force) { //ehh boring bit dont touch
    acc.add(force);
  }
   public void arrive(PVector target) { //provides a nice easing approach to target (food or mate)
    //fill(0);
    //text("eat", loc.x, loc.y+10);
    PVector desired = PVector.sub(target, loc);
    float d = desired.mag();
    desired.normalize();
    if (d < 20) {
      float m = map(d, 0, 20, 0, maxspeed);
      desired.mult(m);
    } else {
      desired.mult(maxspeed);
    }
    PVector steer = PVector.sub(desired, vel);
    steer.limit(maxforce);
    applyForce(steer);
  }

   public void wall() { //keeps everyone within boundaries
    PVector desired = vel.copy();
    if (loc.x > width-15) {
      desired = new PVector(maxspeed * -1, vel.y);
    } else if (loc.x < 15) {
      desired = new PVector(maxspeed, vel.y);
    }
    if (loc.y > height-15) {
      desired = new PVector(vel.x, maxspeed * -1);
    } else if (loc.y < 15) {
      desired = new PVector(vel.x, maxspeed);
    }
    PVector steer = PVector.sub(desired, vel);
    steer.limit(maxforce);
    applyForce(steer);
  }
}
class Plant {
  PVector loc;
  PVector vel;
  PVector acc;
  float tx, ty, tz;
  float px, py;
  float maxspeed, maxforce;
  float nx, ny = 0.0f;
  float r;

  Plant() {
    loc = new PVector(random(width), random(height));
    acc = new PVector(0, 0);
    vel = new PVector(0, 0);
    
    r = random(0, 10);

    maxspeed = map(r, 0, 10, 0.05f, 0.5f);
    maxforce = 0.9f;

    px = loc.x;
    py = loc.y;

    tx = random(100);
    ty = random(10000);
    tz = random(10);
  }

   public void run(ArrayList<Plant> plnt) {
    update();
    wall();
    regen(plnt);
    display();
  }

   public void update() {
    nx = map(noise(tx, tz), 0, 1, -0.1f, 0.1f);
    ny = map(noise(ty, tz), 0, 1, -0.1f, 0.1f);
    acc.y = ny;
    acc.x = nx;
    vel.add(acc);
    vel.limit(maxspeed);
    loc.add(vel);
    acc.mult(0);
    tx += 0.1f;
    ty += 0.1f;
    tz += 0.01f;
  }

   public void display() {
    noStroke();
    fill(309);
    ellipse(loc.x, loc.y, r, r);
  }
   public void wall() {
    PVector desired = vel.copy();
    if (loc.x > width-30) {
      desired = new PVector(maxspeed * -1, vel.y);
    } else if (loc.x < 30) {
      desired = new PVector(maxspeed, vel.y);
    }
    if (loc.y > height-30) {
      desired = new PVector(vel.x, maxspeed * -1);
    } else if (loc.y < 30) {
      desired = new PVector(vel.x, maxspeed);
    }
    PVector steer = PVector.sub(desired, vel);
    steer.limit(maxforce);
    applyForce(steer);
  }
   public void applyForce(PVector force) {
    acc.add(force);
  }
   public void regen(ArrayList<Plant> plnt) {
    if ((random(1) < PlantRegenVal)&&(plnt.size()<maxPlantVal)) {
      plnt.add(new Plant());
    }

    if (plnt.size()<minPlantVal) {
      plnt.add(new Plant());
    }
  }
}


//  ArrayList getPlant() {
//    return plant;
//  }
//}
class World {
  ArrayList<Plant> plnt;
  ArrayList<Opus> op;
  ArrayList<Hachi> hc;

  //variables for displaying stats
  float OpusAvgSpeed = 0;
  float OpusAvgHtr = 0;
  float OpusAvgVision = 0;
  float OpusAvgAge = 0;
  float HachiAvgSpeed = 0;
  float HachiAvgHtr = 0;
  float HachiAvgVision = 0;
  float HachiAvgAge = 0;


  World(int h_, int o_, int p_) { //loads up number of entities
    plnt = new ArrayList<Plant>();
    for (int i=0; i<p_; i++) {
      plnt.add(new Plant());
    }
    op = new ArrayList<Opus>();
    for (int i=0; i<o_; i++) {
      PVector l = new PVector(random(width), random(height));
      DNA dna = new DNA();
      op.add(new Opus(l, dna));
    }
    hc = new ArrayList<Hachi>();
    for (int i=0; i<h_; i++) {
      PVector l = new PVector(random(width), random(height));
      DNA dna = new DNA();
      hc.add(new Hachi(l, dna));
    }
  }

   public void run() {
    //Stats Display
    textSize(14);
    fill(0);
    textFont(myFontC);
    text("Hachi: "+hc.size(), 360, height-60);
    text("Opus: "+op.size(), 10, height-60);

    textFont(myFontI);
    textSize(12);

    text("Speed", 10, height-40);
    text("Rpdc", 60, height-40);
    text("Vision", 110, height-40);
    text("Age", 160, height-40);
    text(OpusAvgSpeed/op.size(), 10, height-23);
    text(OpusAvgHtr/op.size(), 60, height-23);
    text(OpusAvgVision/op.size(), 110, height-23);
    text(OpusAvgAge/op.size(), 160, height-23);
    if (op.size()>0) {
      OpusAvgSpeed = 0;
      OpusAvgHtr = 0;
      OpusAvgVision = 0;
      OpusAvgAge = 0;
    }

    text("Speed", 360, height-40);
    text("Rpdc", 410, height-40);
    text("Vision", 460, height-40);
    text("Age", 510, height-40);
    text(HachiAvgSpeed/hc.size(), 360, height-23);
    text(HachiAvgHtr/hc.size(), 410, height-23);
    text(HachiAvgVision/hc.size(), 460, height-23);
    text(HachiAvgAge/hc.size(), 510, height-23);
    if (hc.size()>0) {
      HachiAvgSpeed = 0;
      HachiAvgHtr = 0;
      HachiAvgVision = 0;
      HachiAvgAge = 0;
    }


    //make everything run
    for (int i=0; i<plnt.size(); i++) {
      Plant part = plnt.get(i);
      part.run(plnt);
    }
    for (int i=0; i<op.size(); i++) {
      Opus part = op.get(i);
      part.run(plnt, op);

      OpusAvgSpeed += map(part.dna.genes[0][0], 0, 1, OpusSpeedMin, OpusSpeedMax);
      OpusAvgHtr += map(part.dna.genes[2][0], 0, 1, OpusHtrMin, OpusHtrMax);
      OpusAvgVision += map(part.dna.genes[1][0], 0, 1, OpusVisionMin, OpusVisionMax);
      OpusAvgAge += map(part.dna.genes[3][0], 0, 1, OpusAgeMin/frameRate, OpusAgeMax/frameRate);
    }
    for (int i=0; i<hc.size(); i++) {
      Hachi part = hc.get(i);
      part.run(op, hc);
      HachiAvgSpeed += map(part.dna.genes[0][0], 0, 1, HachiHungerMin, HachiHungerMax);
      HachiAvgHtr += map(part.dna.genes[2][0], 0, 1, HachiHtrMin, HachiHtrMax);
      HachiAvgVision += map(part.dna.genes[1][0], 0, 1, HachiVisionMin, HachiVisionMax);
      HachiAvgAge += map(part.dna.genes[3][0], 0, 1, HachiAgeMin/frameRate, HachiAgeMax/frameRate);
    }
  }
}


  public void settings() { size(900, 600, FX2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "sketch_AL_5_1_Test" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
